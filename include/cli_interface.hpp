
// This header consists of two parts:
// * cli generator part, which using helper C++ code, included once
// * recursive include part, which used by geenrator part many times,
//   its required, because i want cli_interface to be only one header

// GENERATOR OPTIONS:

// There are some options which you can set:
// * program_options_file - file where options described, "program_options.def" by default
//
// * store_main_args      - if defined, then main arguments will be stored in global storage to be accessed by
// 'program_name' and 'program_args' options
//
// * get_help_text        - by default help message is autogenerated, but if defined,
//                          then 'get_help_text' must name a function which returns std::string_view/const
//                          char*
//

#if !defined(DAVID_DINAMIT_CLI_INTERFACE)
#define DAVID_DINAMIT_CLI_INTERFACE

#include <string_view>
#include <optional>
#include <type_traits>
#include <cassert>
#include <iterator>
#include <iostream>  // TODO remove

namespace cli {

template <typename T, typename Ret = T>
struct string_switch {
  const std::string_view s;
  std::optional<Ret> result;

  constexpr string_switch(std::string_view s) noexcept : s(s) {
  }
  string_switch(string_switch&&) = delete;
  void operator=(string_switch&&) = delete;
  ~string_switch() = default;

  constexpr string_switch&& case_(std::string_view str,
                                  T value) && noexcept(std::is_nothrow_move_constructible_v<T>) {
    if (!result && s == str)
      result.emplace(std::move(value));
    return (string_switch &&) * this;
  }
  [[nodiscard]] constexpr Ret default_(T Value) && noexcept(std::is_nothrow_move_constructible_v<Ret>) {
    if (result)
      return std::move(*result);
    return Value;
  }
  [[nodiscard]] constexpr operator Ret() && noexcept(std::is_nothrow_move_constructible_v<Ret>) {
    assert(!!result);
    return std::move(*result);
  }
};

using arg = const char*;

struct args_t {
  const arg* first = nullptr;
  const arg* last = nullptr;

  constexpr const arg* begin() const noexcept {
    return first;
  }
  constexpr const arg* end() const noexcept {
    return last;
  }
};

// context of current parsing
struct context {
  args_t args;  // may be used to continue parsing
  size_t position = size_t(-1);
};

enum struct errc {
  ok,
  argument_missing,   // option reqires arg and it is missing
  arg_parsing_error,  // from_cli(string_view, option&) returns 'false'
  invalid_argument,   // argument is presented, but its invalid (not in enum or not bool etc)
};

struct error_code {
  errc what = errc::ok;
  context ctx;

  constexpr void set_error(errc ec, const context& ctx_) noexcept {
    what = ec;
    ctx = ctx_;
  }
  constexpr void clear() noexcept {
    what = errc::ok;
  }
  constexpr explicit operator bool() const noexcept {
    return what != errc::ok;
  }
  // TODO constexpr ??? message() or log to?(without allocating anyway)
};

constexpr inline args_t args_range(int argc, const arg* argv) noexcept {
  assert(argc >= 0);
  if (argc == 0)
    return args_t{};
  return args_t{argv + 1, argv + argc};
}

namespace noexport {

constinit inline struct {
  // invariant : if count > 0, then argv != nullptr
  int argc = 0;
  const arg* argv = nullptr;
} args = {};

}  // namespace noexport

#ifdef store_main_args

// returns empty string if 'cli::parse' not called yet or argv == 0
// otherwise returns argv[0]
// note: if you change 'argv' in 'main' you will observe it from this function, but why you rly dont needed it
inline std::string_view program_name() noexcept {
  const auto& args = noexport::args;
  return args.argc != 0 ? args.argv[0] : std::string_view{};
}

// returns empty range, if 'cli::parse' not called yet
// program args do not include first argument, which is program_name
inline args_t program_args() noexcept {
  const auto& args = noexport::args;
  return args_range(args.argc, args.argv);
}

#endif  // store_main_args

struct options {
#define DD_CLI
#define DD_CLIdefault(...) = __VA_ARGS__
// TODO handle command
#define tag_option(name, description) bool name = false;
#define bool_option(name, description, default_value) bool name DD_CLI##default_value;
#define string_option(name, description, default_value) std::string_view name DD_CLI##default_value;

#include __FILE__

#undef DD_CLI
#undef DD_CLIdefault
};

#ifndef get_help_text

#define DD_CLI_STR
#define DD_CLI_STRdefault(...) #__VA_ARGS__

// TODO autogenerate usage (from required options etc)
consteval std::string_view autogenerated_help_text() noexcept {
  // TODO equalizer = "very long string on spaces"
#define string_option(name, description, default_value) \
  "  --" #name " <string arg>\t" description ", default: " DD_CLI_STR##default_value "\n"
#define bool_option(name, description, default_value) \
  "  --" #name " <bool arg>\t" description ", default: " DD_CLI_STR##default_value "\n"
#define tag_option(name, description) "  --" #name "\t" description "\n"
  // TODO handle all option types
  return std::string_view{
#include __FILE__
  };
}

#undef DD_CLI_STR
#undef DD_CLI_STRdefault

#endif  // get_help_text

constexpr errc from_cli(std::string_view raw_arg, std::string_view& s) noexcept {
  s = raw_arg;
  return errc::ok;
}
constexpr errc from_cli(std::string_view raw_arg, bool& b) noexcept {
  // TODO better switch
  int i = string_switch<int>(raw_arg)
              .case_("on", true)
              .case_("1", true)
              .case_("ON", true)
              .case_("off", false)
              .case_("OFF", false)
              .case_("0", false)
              .default_(2);
  if (i == 2)
    return errc::invalid_argument;
  b = i;
  return errc::ok;
}

// TODO void continue_parse(args, options&, error_code&)

// if option if to save program name, then this function not thread safe in theory, but rly.. dont call it
// multithread))
constexpr options parse(args_t args, error_code& ec) noexcept {
  options o;
  auto set_error_on_pos = [&](auto it, errc what) {
    ec.set_error(what, context{args_t{it, args.end()}, (size_t)std::distance(args.begin(), it)});
  };
  auto try_parse = [&](auto it, auto& option_value) -> errc {
    if (it == args.end())
      return errc::argument_missing;
    return from_cli(std::string_view(*it), option_value);
  };

  // parse loop begin

  for (auto it = args.begin(); it != args.end(); ++it) {
    std::string_view s = *it;
    // TODO handle all types of options
#define tag_option(name, ...)              \
  if (s == std::string_view("--" #name)) { \
    o.name = true;                         \
    continue;                              \
  }
#define string_option(name, ...)                                          \
  if (s == std::string_view("--" #name, sizeof(#name) + 1)) {             \
    if (errc ec = try_parse(++it, o.name); ec != errc::ok) [[unlikely]] { \
      set_error_on_pos(it, ec);                                           \
      return o;                                                           \
    }                                                                     \
    continue;                                                             \
  }
#define bool_option(...) string_option(__VA_ARGS__)

#include __FILE__
  }  // parse loop end

  return o;
}

/* TODO constexpr */ options parse(int argc, char* argv[], error_code& ec) noexcept {
  assert(argc >= 0);
  // TODO good condition (contains in options or may be in loop?)
  if (std::string_view(argv[1]) == "--help") {
#ifdef get_help_text
    // TODO replace cout with some stream
    std::cout << get_help_text();
#else
    std::cout << autogenerated_help_text();
#endif
    std::exit(0);  // end of program after help message
  }
#ifdef store_main_args
  noexport::args = {argc, argv};
#endif  // store_main_args
  return parse(args_range(argc, argv), ec);
}

}  // namespace cli

#undef store_main_args
#undef program_options_file
#undef get_help_text

#else  // DAVID_DINAMIT_CLI_INTERFACE (start of self include part)

// TODO doc for all here
#ifndef command
#define command(...)
#endif

#ifndef bool_option
#define bool_option(...)
#endif

#ifndef string_option
#define string_option(...)
#endif

#ifndef tag_option
#define tag_option(...)
#endif

#ifndef enum_option
#define enum_option(...)
#endif

#ifdef path_option
#define path_option(...)
#endif

// file with description of program options, format: TODO link
#ifndef program_options_file
#define program_options_file "program_options.def"
#endif

#include program_options_file

#undef command
#undef bool_option
#undef string_option
#undef tag_option
#undef enum_option
#undef path_option

#endif  //  DAVID_DINAMIT_CLI_INTERFACE (end of self include part)
