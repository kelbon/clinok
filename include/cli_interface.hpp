
// This header consists of two parts:
// * cli generator part, which using helper C++ code, included once
// * recursive include part, which used by geenrator part many times,
//   its required, because i want cli_interface to be only one header

// GENERATOR OPTIONS:

// There are some options which you can set:
// * program_options_file - file where options described, "program_options.def" by default
//
// * store_main_args      - if defined, then main arguments will be stored in global storage to be accessed by
// 'program_name' and 'program_args' options
//
// * get_help_text        - by default help message is autogenerated, but if defined,
//                          then 'get_help_text' must name a function which returns std::string_view/const
//                          char*
//

#if !defined(DAVID_DINAMIT_CLI_INTERFACE)
#define DAVID_DINAMIT_CLI_INTERFACE

#include <string_view>
#include <optional>
#include <type_traits>
#include <cassert>
#include <iterator>
#include <iostream>
#include <algorithm>
#include <initializer_list>

namespace cli {

template <typename T, typename Ret = T>
struct string_switch {
  const std::string_view s;
  std::optional<Ret> result;

  constexpr string_switch(std::string_view s) noexcept : s(s) {
  }
  string_switch(string_switch&&) = delete;
  void operator=(string_switch&&) = delete;
  ~string_switch() = default;

  constexpr string_switch&& case_(std::string_view str,
                                  T value) && noexcept(std::is_nothrow_move_constructible_v<T>) {
    if (!result && s == str)
      result.emplace(std::move(value));
    return (string_switch &&) * this;
  }
  [[nodiscard]] constexpr Ret default_(T Value) && noexcept(std::is_nothrow_move_constructible_v<Ret>) {
    if (result)
      return std::move(*result);
    return Value;
  }
  [[nodiscard]] constexpr operator Ret() && noexcept(std::is_nothrow_move_constructible_v<Ret>) {
    assert(!!result);
    return std::move(*result);
  }
};

using arg = const char*;

struct args_t {
  const arg* first = nullptr;
  const arg* last = nullptr;

  constexpr const arg* begin() const noexcept {
    return first;
  }
  constexpr const arg* end() const noexcept {
    return last;
  }
};

// context of current parsing
struct context {
  args_t args;  // may be used to continue parsing
  size_t position = size_t(-1);
};

enum struct errc {
  ok,
  argument_missing,   // option reqires arg and it is missing
  arg_parsing_error,  // from_cli(string_view, option&) returns 'false'
  invalid_argument,   // argument is presented, but its invalid (not in enum or not bool etc)
};

struct error_code {
  errc what = errc::ok;
  context ctx;

  constexpr void set_error(errc ec, const context& ctx_) noexcept {
    what = ec;
    ctx = ctx_;
  }
  constexpr void clear() noexcept {
    what = errc::ok;
  }
  constexpr explicit operator bool() const noexcept {
    return what != errc::ok;
  }
  // TODO constexpr ??? message() or log to?(without allocating anyway)
};

constexpr inline args_t args_range(int argc, const arg* argv) noexcept {
  assert(argc >= 0);
  if (argc == 0)
    return args_t{};
  return args_t{argv + 1, argv + argc};
}

namespace noexport {

constinit inline struct {
  // invariant : if count > 0, then argv != nullptr
  int argc = 0;
  const arg* argv = nullptr;
} args = {};

}  // namespace noexport

#ifdef store_main_args

// returns empty string if 'cli::parse' not called yet or argv == 0
// otherwise returns argv[0]
// note: if you change 'argv' in 'main' you will observe it from this function, but why you rly dont needed it
inline std::string_view program_name() noexcept {
  const auto& args = noexport::args;
  return args.argc != 0 ? args.argv[0] : std::string_view{};
}

// returns empty range, if 'cli::parse' not called yet
// program args do not include first argument, which is program_name
inline args_t program_args() noexcept {
  const auto& args = noexport::args;
  return args_range(args.argc, args.argv);
}

#endif  // store_main_args

struct options {
#define DD_CLI
#define DD_CLIdefault(...) = __VA_ARGS__
// TODO handle command
#define tag_option(name, description) bool name = false;
#define bool_option(name, description, ...) bool name DD_CLI ## __VA_ARGS__;
#define string_option(name, description, ...) std::string_view name DD_CLI ## __VA_ARGS__;

#include __FILE__

#undef DD_CLI
#undef DD_CLIdefault
};

#define DD_CLI_STR
#define DD_CLI_STRdefault(...) "default: " #__VA_ARGS__ ", "

template <typename...>
struct typelist {};

#define option(type, name_, description_, ...)                                                             \
  struct name_##_desc {                                                                                    \
    using value_type = type;                                                                               \
    static constexpr std::string_view name = #name_;                                                       \
    static constexpr std::string_view description = DD_CLI_STR##__VA_ARGS__ description_; \
  };
#define tag_option(name_, description_)                           \
  struct name_##_desc {                                           \
    using value_type = void;                                      \
    static constexpr std::string_view name = #name_;              \
    static constexpr std::string_view description = description_; \
  };
#include __FILE__

namespace noexport {

struct null_option {};

using all_options = typelist<noexport::null_option
#define option(type, name, ...) , name##_desc
#include __FILE__
                             >;

}  // namespace noexport

// passes empty option description object to 'foo'
constexpr void for_each_option(auto foo) {
  [&]<typename... Options>(typelist<noexport::null_option, Options...>) {
    (foo(Options{}), ...);
  }(noexport::all_options{});
}
// passes all options as empty option description objects to 'foo'
constexpr decltype(auto) apply_to_options(auto foo) {
  return [&]<typename... Options>(typelist<noexport::null_option, Options...>) -> decltype(auto) {
    return foo(Options{}...);
  }(noexport::all_options{});
}
// TODO check if help option exist from user
#ifndef get_help_text

[[noreturn]] inline void print_help_message_and_exit() noexcept {
  auto option_arg_str = []<typename O>(O) {
    if (std::is_same_v<typename O::value_type, std::string_view>)
      return "<string arg>";
    else if (std::is_same_v<typename O::value_type, bool>)
      return "<bool arg>";
    else
      return "";
    // TODO handle path/enum here
  };
  auto option_string_len = [&](auto o) -> size_t {
    return sizeof("--") + o.name.size() + std::strlen(option_arg_str(o));
  };
  size_t largest_help_string = apply_to_options([&](auto... opts) {
    return std::max({size_t(0), option_string_len(opts)...});
  });
  for_each_option([&](auto o) {
    std::cout << " --" << o.name << ' ' << option_arg_str(o)
              << std::string(2 + largest_help_string - option_string_len(o), ' ') << o.description << '\n';
  });
  std::flush(std::cout);
  std::exit(0);
}

#endif  // get_help_text

#undef DD_CLI_STR
#undef DD_CLI_STRdefault

constexpr errc from_cli(std::string_view raw_arg, std::string_view& s) noexcept {
  s = raw_arg;
  return errc::ok;
}
constexpr errc from_cli(std::string_view raw_arg, bool& b) noexcept {
  // TODO better switch
  int i = string_switch<int>(raw_arg)
              .case_("on", true)
              .case_("1", true)
              .case_("ON", true)
              .case_("off", false)
              .case_("OFF", false)
              .case_("0", false)
              .default_(2);
  if (i == 2)
    return errc::invalid_argument;
  b = i;
  return errc::ok;
}

// TODO void continue_parse(args, options&, error_code&)

// if option if to save program name, then this function not thread safe in theory, but rly.. dont call it
// multithread))
constexpr options parse(args_t args, error_code& ec) noexcept {
  options o;
  auto set_error_on_pos = [&](auto it, errc what) {
    ec.set_error(what, context{args_t{it, args.end()}, (size_t)std::distance(args.begin(), it)});
  };
  auto try_parse = [&](auto it, auto& option_value) -> errc {
    if (it == args.end())
      return errc::argument_missing;
    return from_cli(std::string_view(*it), option_value);
  };

  // parse loop begin

  for (auto it = args.begin(); it != args.end(); ++it) {
    std::string_view s = *it;
    // TODO handle all types of options
#define tag_option(name, ...)              \
  if (s == std::string_view("--" #name)) { \
    o.name = true;                         \
    continue;                              \
  }
#define string_option(name, ...)                                          \
  if (s == std::string_view("--" #name, sizeof(#name) + 1)) {             \
    if (errc ec = try_parse(++it, o.name); ec != errc::ok) [[unlikely]] { \
      set_error_on_pos(it, ec);                                           \
      return o;                                                           \
    }                                                                     \
    continue;                                                             \
  }
#define bool_option(...) string_option(__VA_ARGS__)

#include __FILE__
  }  // parse loop end

  return o;
}

/* TODO constexpr */ options parse(int argc, char* argv[], error_code& ec) noexcept {
  assert(argc >= 0);
  // TODO good condition (contains in options or may be in loop?)
  if (std::string_view(argv[1]) == "--help") {
#ifdef get_help_text
    // TODO replace cout with some stream
    std::cout << get_help_text();
    std::exit(0);  // end of program after help message
#else
    print_help_message_and_exit();
#endif
  }
#ifdef store_main_args
  noexport::args = {argc, argv};
#endif  // store_main_args
  return parse(args_range(argc, argv), ec);
}

}  // namespace cli

#undef store_main_args
#undef program_options_file
#undef get_help_text

#else  // DAVID_DINAMIT_CLI_INTERFACE (start of self include part)

// default for all options
#ifndef option
#define option(...)
#endif

// TODO doc for all here
#ifndef command
#define command(...)
#endif

#ifndef bool_option
#define bool_option(...) option(bool, __VA_ARGS__)
#endif

#ifndef string_option
#define string_option(...) option(::std::string_view, __VA_ARGS__)
#endif

#ifndef tag_option
#define tag_option(...) option(void, __VA_ARGS__)
#endif

// TODO value_type? some enumof<name>?
#ifndef enum_option
#define enum_option(...) option(__VA_ARGS__)
#endif

#ifdef path_option
#define path_option(...) option(::std::filesystem::path, __VA_ARGS__)
#endif

// file with description of program options, format: TODO link
#ifndef program_options_file
#define program_options_file "program_options.def"
#endif

#include program_options_file

#undef command
#undef bool_option
#undef string_option
#undef tag_option
#undef enum_option
#undef path_option
#undef option

#endif  //  DAVID_DINAMIT_CLI_INTERFACE (end of self include part)
